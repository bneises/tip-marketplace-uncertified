{
  "IsEnabled": true,
  "IsCustom": true,
  "Integration": "Flashpoint",
  "DocumentationLink": null,
  "Name": "Flashpoint - Compromised Credential Connector",
  "Description": "Flash Point Connector - Credentials Sighting.\nEach time the credentials of an employee in your company are used in the web, alerts will be ingested into Siemplify.\n",
  "Creator": "Admin",
  "Script": "# =====================================\n#              IMPORTS                #\n# =====================================\nfrom SiemplifyUtils import output_handler\nfrom SiemplifyConnectors import SiemplifyConnectorExecution, CaseInfo\nfrom SiemplifyUtils import convert_string_to_unix_time, convert_unixtime_to_datetime, from_unix_time\nimport uuid\nimport sys\nimport datetime, json, time\nfrom FlashpointManager import FlashpointManager, dict_to_flat\n# =====================================\n#             CONSTANTS               #\n# =====================================\nDEFAULT_PRODUCT = 'Flashpoint'\nEVENT_TIME_FIELD = '_source_header__indexed_at'\nALERT_DESCRIPTION_FIELD = \"_source_basetypes_1\"\nALERT_NAME_FIELD = \"_source_basetypes_1\"\nALERT_ID_FIELD = \"_source_id\"\nALERT_WITHOUT_A_RULE_DEFAULT = 'Alert has no rule.'\nALERT_WITHOUT_A_NAME_DEFAULT = 'Alert has no name.'\nALERT_NAME_IS_EMPTY_DEFAULT = 'Alert name is empty.'\nDAYS_IN_SECONDS = 86400\n# =====================================\n#              CLASSES                #\n# =====================================\nclass FlashpointConnectorError(Exception):\n    pass\nclass FlashpointConnector(object):\n    def __init__(self, logger):\n        self.logger = logger\n\n    def create_case(self, threat, device_product_field, environment):\n        \"\"\"\n        Create a case object.\n        :return: {CaseInfo} Case object.\n        \"\"\"\n        case_info = CaseInfo()\n        event = {}\n        event = threat\n        case_info.start_time = threat.get(EVENT_TIME_FIELD)\n        case_info.end_time = threat.get(EVENT_TIME_FIELD)\n        case_info.rule_generator = threat.get(ALERT_DESCRIPTION_FIELD) if not None else \"Flashpoint\"\n        case_info.device_product = threat.get(device_product_field, DEFAULT_PRODUCT)\n        case_info.device_vendor = case_info.device_product\n        case_info.priority = 60\n        case_info.environment = environment\n        case_info.name = threat.get(ALERT_NAME_FIELD, ALERT_WITHOUT_A_NAME_DEFAULT) \\\n            if threat.get(ALERT_NAME_FIELD) else ALERT_NAME_IS_EMPTY_DEFAULT\n        # If no Session ID, replace with timestamp + uuid because timestamp can be not unique in some cases.\n        case_info.ticket_id = threat.get(\"_id\") if not None else str(uuid.uuid4())\n        case_info.display_id = case_info.identifier = case_info.ticket_id\n        event[\"event_name\"] = \"Credential Sighting\"\n        event[\"start_time\"] = case_info.start_time\n        event[\"end_time\"] = case_info.end_time\n        event = dict((k.lower(), v) for k, v in event.items()) \n        case_info.events.append(event)\n        return case_info\n\ndef fetch_last_saved_timestamp(connector_scope, time_now, max_days_backwards):\n    last_fetched_timestamp = connector_scope.fetch_timestamp()\n    last_fetched_timestamp = int(last_fetched_timestamp/1000)\n    connector_scope.LOGGER.info(f\"****The last timestamp that was fetched is {last_fetched_timestamp}****\")\n    if not is_test_run and last_fetched_timestamp > 0:\n        \n        if last_fetched_timestamp >= (time_now - (max_days_backwards*DAYS_IN_SECONDS)):\n            connector_scope.LOGGER.info(f\"The last timestamp that was saved is: {last_fetched_timestamp}\")\n        else:\n            last_fetched_timestamp = time_now-(max_days_backwards*DAYS_IN_SECONDS)\n            connector_scope.LOGGER.info(f\"The last timestamp that was fetched is:{last_fetched_timestamp}\")\n    else:\n        last_fetched_timestamp = time_now-(max_days_backwards*DAYS_IN_SECONDS)\n        if is_test_run:\n            connector_scope.LOGGER.info(f\"This is a test run.The timestamp is:{last_fetched_timestamp}\")\n        else:\n            connector_scope.LOGGER.info(f\"This is a real run, there is no timestamp to fetch. The timestamp is {last_fetched_timestamp}\")\n    return last_fetched_timestamp\n    \n    \n@output_handler\ndef main(is_test_run=False):\n    connector_scope = SiemplifyConnectorExecution()\n    cases = []\n    try:\n        if is_test_run:\n            connector_scope.LOGGER.info(\" ------------ Starting Flashpoint Connector test. ------------ \")\n        else:\n            connector_scope.LOGGER.info(\" ------------ Starting Flashpoint Connector. ------------ \")\n        api_key = connector_scope.extract_connector_param(param_name=\"API Key\")\n        max_days_backwards = connector_scope.extract_connector_param(param_name=\"Max Days Back\", input_type=int)\n        device_product_field = connector_scope.extract_connector_param(param_name=\"DeviceProductField\")\n        limit = connector_scope.extract_connector_param(param_name=\"Limit\")\n        proxy_server_address = connector_scope.extract_connector_param(param_name=\"Proxy Server Address\")\n        proxy_username = connector_scope.extract_connector_param(param_name=\"Proxy Username\")\n        proxy_password = connector_scope.extract_connector_param(param_name=\"Proxy Password\")\n        flashpoint_manager = FlashpointManager(api_key, proxy_server_address, proxy_username, proxy_password)\n        flashpoint_connector = FlashpointConnector(connector_scope.LOGGER)\n        time_now = int(time.time())\n\n        last_timestamp = fetch_last_saved_timestamp(connector_scope, time_now, max_days_backwards)\n    \n        alert_list = flashpoint_manager.search_CCM(last_timestamp, time_now, limit)\n        alert_list = alert_list[\"hits\"][\"hits\"]\n        if is_test_run:\n            alert_list = alert_list[-10:]\n        for alert in alert_list:\n            try:\n                case = flashpoint_connector.create_case(dict_to_flat(alert), device_product_field=device_product_field,\n                                                        environment=connector_scope.context.connector_info.environment)\n                is_overflowed = False\n                try:\n                    is_overflowed = connector_scope.is_overflowed_alert(\n                        environment=case.environment,\n                        alert_identifier=str(case.ticket_id),\n                        alert_name=str(case.rule_generator),\n                        product=str(case.device_product))\n                except Exception as err:\n                    connector_scope.LOGGER.error(\n                        'Error validation connector overflow, ERROR: {0}'.format(unicode(err)))\n                    connector_scope.LOGGER.exception(err)\n                    if is_test_run:\n                        raise\n                if is_overflowed:\n                    connector_scope.LOGGER.info(\n                        \"{alert_name}-{alert_identifier}-{environment}-{product} found as overflow alert. Skipping.\".format(\n                            alert_name=str(case.rule_generator),\n                            alert_identifier=str(case.ticket_id),\n                            environment=str(case.environment),\n                            product=str(case.device_product)))\n                else:\n                    cases.append(case)\n                    connector_scope.LOGGER.info('Case with display id \"{0}\" was created.'.format(case.display_id))\n            except Exception as err:\n                error_message = \"Failed creating case for alert with ID: {0}, ERROR: {1}\".format(\n                    alert.get(ALERT_ID_FIELD), err)\n                connector_scope.LOGGER.error(error_message)\n                connector_scope.LOGGER.exception(err)\n                \n        cases.sort(key=lambda x: x.start_time)   \n        if cases and not is_test_run:\n            connector_scope.save_timestamp(cases[-1].start_time)\n        if is_test_run:\n            connector_scope.LOGGER.info(\n                \" ------------ Complete Flashpoint Compromised Credential Connector test. ------------ \")\n        else:\n            connector_scope.LOGGER.info(\" ------------ Complete Connector Iteration. ------------ \")\n        connector_scope.return_package(cases)\n    except Exception as err:\n        connector_scope.LOGGER.error('Got exception on main handler. Error: {0}'.format(err))\n        connector_scope.LOGGER.exception(err)\n        if is_test_run:\n            raise\n        # This is a test\nif __name__ == \"__main__\":\n    # Connectors are run in iterations. The interval is configurable from the ConnectorsScreen UI.\n    is_test_run = not (len(sys.argv) < 2 or sys.argv[1] == 'True')\n    main(is_test_run)",
  "Version": 283,
  "MappingRules": [],
  "ProductToVisualFamilyRecords": [],
  "SimulationUseCases": {
    "CasesForUseCase": [],
    "UseCaseName": null
  },
  "Parameters": [
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": true,
      "DefaultValue": "123456",
      "Name": "API Key",
      "Type": 3,
      "Mode": 2,
      "Description": "API Key",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": true,
      "DefaultValue": "case_info.device_product",
      "Name": "DeviceProductField",
      "Type": 2,
      "Mode": 0,
      "Description": "The field name used to determine the device product",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": false,
      "DefaultValue": null,
      "Name": "DeviceProductField",
      "Type": 2,
      "Mode": 2,
      "Description": "The field to determine what is the product that generated the alert.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": false,
      "DefaultValue": "event_name",
      "Name": "EventClassId",
      "Type": 2,
      "Mode": 0,
      "Description": "The field name used to determine the event name (sub-type)",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": true,
      "DefaultValue": "4",
      "Name": "Limit",
      "Type": 1,
      "Mode": 2,
      "Description": "The limit of the events to retrieve",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": false,
      "DefaultValue": "100",
      "Name": "Max Days Back",
      "Type": 1,
      "Mode": 2,
      "Description": "The max days back to retrieve data from",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": false,
      "DefaultValue": "",
      "Name": "Proxy Password",
      "Type": 3,
      "Mode": 2,
      "Description": "The proxy password to authenticate with.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": false,
      "DefaultValue": null,
      "Name": "Proxy Server Address",
      "Type": 2,
      "Mode": 2,
      "Description": "The address of the proxy server to use.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": false,
      "DefaultValue": null,
      "Name": "Proxy Username",
      "Type": 2,
      "Mode": 2,
      "Description": "The proxy username to authenticate with.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    },
    {
      "ConnectorDefinitionId": 4,
      "IsMandatory": true,
      "DefaultValue": "60",
      "Name": "PythonProcessTimeout",
      "Type": 2,
      "Mode": 0,
      "Description": "The timeout limit (in seconds) for the python process running current script",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1621443154528,
      "ModificationTimeUnixTimeInMs": 1621443154528
    }
  ],
  "Rules": [],
  "IsConnectorRulesSupported": true,
  "IsSystem": false,
  "PythonVersion": "None",
  "Id": 0,
  "CreationTimeUnixTimeInMs": 1621443154516,
  "ModificationTimeUnixTimeInMs": 1621443154518
}
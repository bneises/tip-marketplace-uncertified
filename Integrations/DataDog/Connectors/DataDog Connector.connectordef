{
  "IsEnabled": true,
  "IsCustom": false,
  "Integration": "DataDog",
  "DocumentationLink": null,
  "Name": "DataDog Connector",
  "Description": "Ingest events from DataDog by given filters(e.g. tags, priority)",
  "Creator": "Admin",
  "Script": "from SiemplifyConnectors import SiemplifyConnectorExecution\nfrom SiemplifyConnectorsDataModel import AlertInfo\nfrom SiemplifyUtils import output_handler, convert_datetime_to_unix_time, convert_string_to_datetime, dict_to_flat\nfrom SiemplifyAction import SiemplifyAction\nfrom DataDogManager import DataDogManager, dict_to_flat\nimport sys, json, arrow, os, re, time\n\n# CONSTANTS\nIDENTIFIER=\"DataDog\"\nCONNECTOR_NAME = \"DataDog Connector\"\nVENDOR = PRODUCT = \"DataDog\"\nDEFAULT_PRIORITY = {\"error\":100, \"warning\":80, \"ok\":-1}\nBASE_URL = 'https://api.datadoghq.com'\nREGEX_VALUE_BEFORE_COLON = '^[^:]*\\s*'\nREGEX_VALUE_AFTER_COLON ='[^:]*$'\nDAY_IN_SECONDS = 86400\n\ndef create_alert(siemplify, created_event, base_url):\n    \"\"\"\n    Create the alert and ingest it into the platform\n    \"\"\"\n    alert_id =  created_event.get(\"id\")\n    siemplify.LOGGER.info(f\"----- Started processing Alert {alert_id}-----\")\n    alert_info = AlertInfo()\n    \n    # Initializes the alert_info Characteristics Fields\n    alert_info.ticket_id = alert_id\n    alert_info.display_id = alert_id# Each alert needs to have a unique id, otherwise it won't  create a case with the same alert id.\n    alert_info.name = created_event.get(\"monitor_name\")\n    alert_info.rule_generator = created_event.get('metric')# The name of the siem rule which causes the creation of the alert.\n    alert_info.start_time = created_event.get('date_happened') # Time should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    alert_info.end_time =  created_event.get('date_happened') # Time should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    alert_info.priority = DEFAULT_PRIORITY.get(created_event.get('alert_type'), -1)\n    alert_info.device_vendor = VENDOR # The field will be fetched from the Original Alert. If you build this alert manually, state the source vendor of the data. (ie: Microsoft, Mcafee)\n    alert_info.device_product = created_event.get('device_product') # The field will be fetched from the Original Alert. If you build this alert manually, state the source product of the data. (ie: ActiveDirectory, AntiVirus)\n    # ----------------------------- Alert Fields initialization END -----------------------------#\n\n    alert_info.events.append(created_event)\n    siemplify.LOGGER.info(f\"The event {created_event.get('id')} was Added to Alert {alert_id}\")\n    return alert_info\n        \ndef create_event(siemplify,event_full_details, base_url):\n    \"\"\"\n    Returns the digested data of a single alert triggered by a monitor\n    \"\"\"\n    siemplify.LOGGER.info(f\"--- Started processing Event---\")\n    event = {}\n    product_name = \"Product name wasn't found\"\n    #Extracting the tag key and value e.g pod_name:podnameexample\n    if event_full_details.get(\"event\").get(\"tags\") is not None:\n        for tag in event_full_details.get(\"event\").get(\"tags\"):\n            tag_key = (re.search(REGEX_VALUE_BEFORE_COLON, tag)).group(0)\n            tag_value = (re.search(REGEX_VALUE_AFTER_COLON, tag)).group(0)\n            event[tag_key]=tag_value\n    #Extracting the metric field from payload\n    event = dict_to_flat(event_full_details.get(\"event\"))\n    event_payload = json.loads(event_full_details.get(\"event\").get(\"payload\"))\n    event_monitor_name = event_payload.get(\"monitor\").get(\"name\")\n    #Extracting the even metric name\n    event_metric = event_payload.get('result').get('metadata').get('metric')\n    \n    #Extracting the product name depends on the event metric name.\n    if event_metric is not None:\n        event_metric_list = event_metric.split('.')\n        if event_metric_list[0]=='aws':\n            product_name = f\"{event_metric_list[0]} {event_metric_list[1]}\"\n        else:\n            product_name = event_metric_list[0]\n    else:\n        event_metric = product_name = event_monitor_name\n        \n\n    event[\"metric\"] = event_metric\n    event[\"monitor_id\"] = event_payload.get(\"monitor\").get(\"id\")\n    event[\"monitor_name\"] = event_monitor_name\n    event[\"alert_url\"] = f\"{base_url}\"+event_payload.get('result').get('metadata').get('alert_url')\n    event[\"graph_snapshot_url\"] = event_payload.get('result').get('metadata').get('snap_url')\n    event[\"device_product\"] = product_name # ie: \"device_product\" is the field name that describes the product the event originated from.\n    event[\"url\"] = f\"{base_url}{event.get('url')}\"\n    event[\"start_time\"] = event_full_details.get(\"event\").get('date_happened') # Time should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    event[\"end_time\"] = event_full_details.get(\"event\").get('date_happened')# Time should be saved in UnixTime. You may use SiemplifyUtils.convert_datetime_to_unix_time, or SiemplifyUtils.convert_string_to_datetime\n    event[\"event_name\"] = event_payload.get(\"monitor\").get(\"name\")\n    siemplify.LOGGER.info(f\"--- Finished processing Event: {event.get('event_name')}\")\n    return event\n\ndef fetch_last_saved_timestamp(siemplify, time_now, max_days_back):\n    last_saved_timestamp = siemplify.fetch_timestamp()\n    if (last_saved_timestamp > 0 and not is_test_run) and last_saved_timestamp <= max_days_back:\n        last_saved_timestamp = int(last_saved_timestamp/1000)\n        siemplify.LOGGER.info(f\"The last timestamp that was saved is:{last_saved_timestamp}\")\n\n    else:\n        last_saved_timestamp = time_now-(max_days_back*DAY_IN_SECONDS)\n        siemplify.LOGGER.info(f\"There is no timestamp to fetch, the new timestamp is:{last_saved_timestamp}\")\n    return last_saved_timestamp\n    \n@output_handler\ndef main(is_test_run):\n    siemplify = SiemplifyConnectorExecution() # Siemplify main SDK wrapper\n    siemplify.script_name = CONNECTOR_NAME \n    alerts = [] # The main output of each connector run that contains the alerts data\n    collected_timestamps = []\n    #In case of running a test\n    if is_test_run:\n        siemplify.LOGGER.info(\"***** This is an \\\"IDE Play Button\\\"\\\\\\\"Run Connector once\\\" test run ******\")\n    #Extracting the connector's params\n    api_key = siemplify.extract_connector_param(param_name=\"API Key\")\n    app_key = siemplify.extract_connector_param(param_name=\"APP Key\")\n    sources = siemplify.extract_connector_param(param_name=\"Sources\")\n    tags = siemplify.extract_connector_param(param_name = \"Tags\")\n    priority = siemplify.extract_connector_param(param_name=\"Priority\")\n    unaggregated = siemplify.extract_connector_param(param_name=\"Unaggregated\", input_type=bool)\n    max_days_back = siemplify.extract_connector_param(param_name = \"Max Days Back\", input_type = int)\n    base_url = siemplify.extract_connector_param(param_name = \"Base URL\")\n\n    #Creating an instance of DataDog object\n    datadog_manager = DataDogManager(api_key, app_key)\n    time_now = int(time.time())\n\n    last_saved_timestamp = fetch_last_saved_timestamp(siemplify, time_now, max_days_back)\n\n    #Get all the new triggered error alerts from all monitors\n    events_data = datadog_manager.get_datadog_events(last_saved_timestamp, time_now, sources,tags, priority, unaggregated)\n    if len(events_data.get(\"events\")) > 0:\n        for i, event_parent_data in enumerate(events_data.get(\"events\")):\n            parent_alert_type = event_parent_data.get(\"alert_type\")\n            if event_parent_data.get(\"date_happened\")>last_saved_timestamp and (parent_alert_type=='error' or parent_alert_type=='warning'):\n                siemplify.LOGGER.info(f\"The event parent ID is:{event_parent_data.get('id')}\")\n                if event_parent_data.get(\"children\") is not None:\n                    #If the event has children events, each of the children events will be considered as an alert\n                    for event in event_parent_data.get(\"children\"):\n                        event_full_details = datadog_manager.get_event_details(event.get(\"id\"))\n                        #Creating the event\n                        created_event = create_event(siemplify, event_full_details, base_url)\n                        # Creating the alert\n                        created_alert = create_alert(siemplify, created_event, base_url)\n                        alerts.append(created_alert)\n                        siemplify.LOGGER.info(f\"Added Alert {created_alert.display_id} to package results\")\n                        collected_timestamps.append(event.get(\"date_happened\"))\n\n                        \n                else:\n                    collected_timestamps.append(event_parent_data.get(\"date_happened\"))\n                    #If the event doesn't have children events we will get the parent event\n                    event_full_details = datadog_manager.get_event_details(event_parent_data.get('id'))\n                    #Creating the event\n                    created_event = create_event(siemplify, event_full_details, base_url)\n                    # Creating the alert\n                    created_alert = create_alert(siemplify, created_event, base_url)\n                    alerts.append(created_alert)\n                    siemplify.LOGGER.info(f\"Added Alert {created_alert.display_id} to package results\")\n\n\n    else:\n        siemplify.LOGGER.info(f\"There are no new events to digest\")\n        \n    if not is_test_run:\n        siemplify.LOGGER.info(f\"The timestamps that were collected are: {collected_timestamps}\")\n        siemplify.save_timestamp(max(collected_timestamps))\n        siemplify.LOGGER.info(f\"The new timestamp that was saved: {max(collected_timestamps)} \")\n\n    #Returning all the created alerts to the cases module in Siemplify\n    siemplify.return_package(alerts)\n            \n\n\nif __name__ == \"__main__\":\n    # Connectors run in iterations. The interval is configurable from the ConnectorsScreen UI.\n    is_test_run = not (len(sys.argv) < 2 or sys.argv[1] == 'True')\n    main(is_test_run)",
  "Version": 782,
  "MappingRules": [],
  "ProductToVisualFamilyRecords": [],
  "SimulationUseCases": {
    "CasesForUseCase": [],
    "UseCaseName": null
  },
  "Parameters": [
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "",
      "Name": "API Key",
      "Type": 3,
      "Mode": 2,
      "Description": "API Key",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "",
      "Name": "APP Key",
      "Type": 3,
      "Mode": 2,
      "Description": "APP Key",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": " https://api.datadoghq.com",
      "Name": "Base URL",
      "Type": 2,
      "Mode": 2,
      "Description": "The Base url ",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "device_product",
      "Name": "DeviceProductField",
      "Type": 2,
      "Mode": 0,
      "Description": "The field name used to determine the device product",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "event_name",
      "Name": "EventClassId",
      "Type": 2,
      "Mode": 0,
      "Description": "The field name used to determine the event name (sub-type)",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "7",
      "Name": "Max Days Back",
      "Type": 1,
      "Mode": 2,
      "Description": "Max days back ",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": false,
      "DefaultValue": "all",
      "Name": "Priority",
      "Type": 2,
      "Mode": 2,
      "Description": "The priority of the events you want to retrieve. \nCould be 'low', 'normal' or 'all'",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "30",
      "Name": "PythonProcessTimeout",
      "Type": 2,
      "Mode": 0,
      "Description": "The timeout limit (in seconds) for the python process running current script",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": true,
      "DefaultValue": "alert",
      "Name": "Sources",
      "Type": 2,
      "Mode": 2,
      "Description": "The sources to retrieve the events from.\nFor example in order to see events from the triggered monitor write: 'alert' .",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": false,
      "DefaultValue": "monitor",
      "Name": "Tags",
      "Type": 2,
      "Mode": 2,
      "Description": "A comma separated list of tags that will filter the list of monitors by scope.\nFor example: 'monitor'.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    },
    {
      "ConnectorDefinitionId": 38,
      "IsMandatory": false,
      "DefaultValue": "true",
      "Name": "Unaggregated",
      "Type": 0,
      "Mode": 2,
      "Description": "True- if you want to retrieve the full list of events.\nFalse - if you want to retrieve aggregated list of events.",
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1615195531896,
      "ModificationTimeUnixTimeInMs": 1615195531896
    }
  ],
  "Rules": [],
  "IsConnectorRulesSupported": true,
  "IsSystem": false,
  "PythonVersion": "None",
  "Id": 0,
  "CreationTimeUnixTimeInMs": 1615195531887,
  "ModificationTimeUnixTimeInMs": 1615195531887
}
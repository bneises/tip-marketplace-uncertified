{
  "Name": "Parse Base64 Email",
  "Description": "This action is an improved version of Parse EML Base64 blob.  It will parse EML and MSG files.",
  "Script": "import json\nimport datetime\nfrom urlextract import URLExtract\nimport EmailParser\nimport extract_msg\n#from base64 import b64decode\nimport base64\nimport sys\nimport olefile\nfrom msg_parser import MsOxMessage\nfrom msg_parser.email_builder import EmailFormatter\nimport hashlib\nimport re\nimport collections\nfrom collections import Counter\nimport EmailParserDecode\nimport EmailParserRegex\nimport EmailParserRouting\nimport ipaddress\nimport os.path\nimport typing\nimport urllib\nfrom SiemplifyAction import *\nfrom ScriptResult import EXECUTION_STATE_COMPLETED, EXECUTION_STATE_FAILED, EXECUTION_STATE_TIMEDOUT\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n\n    if isinstance(obj, datetime.datetime):\n        serial = obj.isoformat()\n        return serial\n    elif isinstance(obj, bytes):\n\n        return base64.b64encode(obj).decode()\n    raise TypeError(\"Type not serializable\")\n\ndef parse_headers(msg, blacklist=[], is_whitelist=False, stop_transport=\"\"):\n    header = []\n    transport = []\n    transport_stopped = False\n    for r in msg.header._headers[::-1]:\n        if stop_transport and r[0].lower() == stop_transport.lower():\n            transport_stopped = True\n        if r[0].lower() == \"received\" and not transport_stopped:\n            trans = {\"Name\": r[0].lower(), \"Header\": r[1]}\n            trans.update(parse_transport(r[0], r[1]))\n            transport.append(trans)\n        if is_whitelist:\n            if r[0].lower() in blacklist:\n                h = {\"Name\": r[0].lower(), \"Header\": r[1]}\n                h.update(parse_transport(r[0], r[1]))\n                header.append(h)\n        else:\n            if r[0].lower() not in blacklist:\n                h = {\"Name\": r[0].lower(), \"Header\": r[1]}\n                h.update(parse_transport(r[0], r[1]))\n                header.append(h)\n    \n    return header, transport\n\n\ndef string_sliding_window_loop(body: str, slice_step: int = 500) -> typing.Iterator[str]:\n    \"\"\"Yield a more or less constant slice of a large string.\n    If we start directly a *re* findall on 500K+ body we got time and memory issues.\n    If more than the configured slice step, lets cheat, we will cut around the thing we search \"://, @, .\"\n    in order to reduce regex complexity.\n    Args:\n        body: Body to slice into smaller pieces.\n        slice_step: Slice this number or characters.\n    Returns:\n        typing.Iterator[str]: Sliced body string.\n    \"\"\"\n    body_length = len(body)\n    if body_length <= slice_step:\n        yield body\n\n    else:\n        ptr_start = 0\n        for ptr_end in range(slice_step, body_length, slice_step):\n            if ' ' in body[ptr_end - 1:ptr_end]:\n                while not (EmailParserRegex.window_slice_regex.match(body[ptr_end - 1:ptr_end]) or ptr_end > body_length):\n                    if ptr_end > body_length:\n                        ptr_end = body_length\n                        break\n\n                    ptr_end += 1\n\n            yield body[ptr_start:ptr_end]\n\n            ptr_start = ptr_end\n\ndef get_uri_ondata(body: str) -> typing.List[str]:\n    \"\"\"Function for extracting URLs from the input string.\n    Args:\n        body (str): Text input which should be searched for URLs.\n    Returns:\n        list: Returns a list of URLs found in the input string.\n    \"\"\"\n    list_observed_urls: typing.Counter[str] = Counter()\n    \n    extractor = URLExtract()\n\n    for found_url in extractor.find_urls(body):\n        if '.' not in found_url:\n            # if we found a URL like e.g. http://afafasasfasfas; that makes no\n            # sense, thus skip it\n            continue\n        list_observed_urls[found_url] = 1\n            #found_url = urllib.parse.urlparse(found_url).geturl()\n            # let's try to be smart by stripping of noisy bogus parts\n            #found_url = re.split(r'''[', \")}\\\\]''', found_url, 1)[0]\n            #list_observed_urls[found_url] = 1\n    return list(list_observed_urls)    \n\n\ndef parse_body(body):\n#    ep = eml_parser.EmlParser()    \n    parsed = {}\n    list_observed_urls: typing.List[str] = []\n    list_observed_email: typing.Counter[str] = Counter()\n    list_observed_dom: typing.Counter[str] = Counter()\n    list_observed_ip: typing.Counter[str] = Counter()\n    #print('parsing body')\n\n    for body_slice in string_sliding_window_loop(body):\n        list_observed_urls = get_uri_ondata(body_slice)\n        extractor = URLExtract(extract_email = True)\n        \n        for match in extractor.find_urls(body_slice):\n        #for match in EmailParserRegex.email_regex.findall(body_slice):\n            c = URLExtract()\n            removedurl = c.find_urls(match)\n            if not removedurl:\n                match = match.replace('mailto:', '')\n                list_observed_email[match.lower()] = 1\n        for match in list_observed_urls:\n            try:\n                dom = get_fld(match.lower(), fix_protocol=True)\n                list_observed_dom[dom] = 1\n            except Exception as t:\n                pass    \n            #list_observed_dom[match.lower()] = 1\n        for match in EmailParserRegex.ipv4_regex.findall(body_slice):\n            try:\n                ipaddress_match = ipaddress.ip_address(match)\n            except ValueError:\n                continue\n            else:\n                if not (ipaddress_match.is_private):\n                    list_observed_ip[match] = 1\n        for match in EmailParserRegex.ipv6_regex.findall(body_slice):\n            try:\n                ipaddress_match = ipaddress.ip_address(match)\n            except ValueError:\n                continue\n            else:\n                if not (ipaddress_match.is_private):\n                    list_observed_ip[match] = 1 \n    if list_observed_urls:\n        parsed['uri'] = list(list_observed_urls)\n    if list_observed_email:\n        parsed['email'] = list(list_observed_email)\n    if list_observed_dom:\n        parsed['domain'] = list(list_observed_dom)\n    if list_observed_ip:\n        parsed['ip'] = list(list_observed_ip)\n    return parsed\n\n\ndef parse_transport(name, header):\n    headers_struc = {}\n    if \"received\" in name.lower():\n        headers_struc['received'] = []\n    headers_struc['email'] = []\n    headers_struc['domain'] = []\n    headers_struc['ip'] = []\n    headers_struc['ipv4'] = []\n    headers_struc['ipv6'] = []\n    \n    try:\n        found_smtpin: collections.Counter = collections.Counter()  # Array for storing potential duplicate \"HOP\"\n        if header:\n            line = str(header).lower()\n            received_line_flat = re.sub(r'(\\r|\\n|\\s|\\t)+', ' ', line, flags=re.UNICODE)\n            parsed_routing = \"\"\n            if \"received\" in name.lower():\n                parsed_routing = EmailParserRouting.parserouting(received_line_flat) \n                headers_struc['received'].append(parsed_routing)\n            ips_in_received_line_v4 = EmailParserRegex.ipv4_regex.findall(received_line_flat)\n            ips_in_received_line_v6 = EmailParserRegex.ipv6_regex.findall(received_line_flat)\n            \n            for ip in ips_in_received_line_v4:\n                try:\n                    ip_obj = ipaddress.ip_address(ip)\n                except ValueError:\n                    print('Invalid IP in received line - \"{}\"'.format(ip))\n                else:\n                    if not (ip_obj.is_private):\n                        headers_struc['ipv4'].append(str(ip_obj))\n            \n            for ip in ips_in_received_line_v6:\n                try:\n                    ip_obj = ipaddress.ip_address(ip)\n                except ValueError:\n                    print('Invalid IP in received line - \"{}\"'.format(ip))\n                else:\n                    if not (ip_obj.is_private):\n                        headers_struc['ipv6'].append(str(ip_obj))\n\n                # search for domain\n            for m in EmailParserRegex.recv_dom_regex.findall(received_line_flat):\n                try:\n                    ip_obj = ipaddress.ip_address(m) \n                except ValueError:\n                        # we find IPs using the previous IP crawler, hence we ignore them\n                        # here.\n                        # iff the regex fails, we add the entry\n                    headers_struc['domain'].append(m)\n\n                # search for e-mail addresses\n            for mail_candidate in EmailParserRegex.email_regex.findall(received_line_flat):\n                #print(mail_candidate)\n                if parsed_routing and mail_candidate not in parsed_routing.get('for', []):\n                    headers_struc['email'] += [mail_candidate]\n            #print(headers_struc['email'])\n\n    except TypeError:  # Ready to parse email without received headers.\n        raise Exception('Exception occurred while parsing received lines.')\n\n    \n    headers_struc['email'] = list(set(headers_struc['email']))\n    headers_struc['domain'] = list(set(headers_struc['domain']))\n    headers_struc['ip'] = list(set(headers_struc['ipv4'])) + list(set(headers_struc['ipv6']))\n\n    return headers_struc\n\n\t\n\n\ndef attachment(filename, content):\n    attachment_json = {\n        'filename': filename,\n        'size': len(content),\n        'extension': os.path.splitext(filename)[1][1:],\n        'hash': {\n            'md5': hashlib.md5(content).hexdigest(),\n            'sha1': hashlib.sha1(content).hexdigest(),\n            'sha256': hashlib.sha256(content).hexdigest(),\n            'sha512': hashlib.sha512(content).hexdigest()\n         },\n         'raw': base64.b64encode(content).decode()\n    }\n    return attachment_json\n\ndef body(msg, content_type):\n    \n    body_json = {\n            'content_type': content_type,\n\n           'content': msg if msg is not None\n                                    else '',\n           'hash': hashlib.sha256(str(msg).encode('utf-8')).hexdigest()\n    }        \n    body_json.update(parse_body(msg))\n    return body_json\n\ndef header(x_msg, o_msg, blacklist, is_whitelist, stop_transport):\n    to_smtp = 'null'\n    from_smtp = 'null'\n    if 'ReceivedByAddressType' in o_msg:\n        if o_msg['ReceivedByAddressType'] == 'EX':\n            to_smtp = 'ReceivedBySmtpAddress'\n        else:\n            to_smtp = 'ReceivedByEmailAddress'\n\n        if o_msg['SenderAddressType'] == 'EX':\n            from_smtp = 'SenderSmtpAddress'\n        else:\n            from_smtp = 'SenderEmailAddress'\n    if to_smtp in o_msg:\n        to = o_msg.get(to_smtp)\n    else: \n        to = x_msg.to\n\n    if from_smtp in o_msg:\n        from_header = o_msg.get(from_smtp)\n    else:\n        from_header = x_msg.sender\n\n    headers, transport = parse_headers(x_msg, blacklist, is_whitelist, stop_transport)\n\n    header_json = {\n        'to': [ to ], \n        'from': from_header,\n        'subject': o_msg['Subject'] if 'Subject' in o_msg else x_msg.subject,\n        'cc': x_msg.cc,\n        'date': x_msg.date,\n        'header': headers,\n        'transport': transport\n        }\n\n    return header_json\n\n\n\n    \ndef fill_json(x_msg, o_msg, blacklist, is_whitelist, stop_transport):\n    \n    _current_json = {\n       'header': header(x_msg, o_msg, blacklist, is_whitelist, stop_transport),\n       \n       'body': [\n           body(x_msg.body, 'text/plain')\n           ],\n        }\n    if x_msg.htmlBody:\n        _current_json['body'].append(body(x_msg.htmlBody, 'text/html'))\n    return _current_json    \n    \ndef parse_msg(msg, blacklist, is_whitelist, stop_transport):\n    \n    x_msg = extract_msg.Message(msg)\n    msg_obj = MsOxMessage(msg)\n    msox_msg = msg_obj._message.as_dict()\n    \n    _cur_json = fill_json(x_msg, msox_msg, blacklist, is_whitelist, stop_transport)\n    _cur_json['attached_emails'] = {}\n    _cur_json['attachment'] = []\n\n    # add the attachments to current json\n    _att_counter = 0\n    for _attachment in x_msg.attachments:\n        #_attachment.save()\n        msox_obj = None\n        for msox_attachments in msox_msg['attachments']:\n            if msox_msg['attachments'][msox_attachments]['AttachFilename'] == _attachment.shortFilename:\n                msox_obj = msox_msg['attachments'][msox_attachments]\n\n        if _attachment.type in 'msg':\n            _attached_json = fill_json(_attachment.data, msox_obj['EmbeddedMessage']['properties'], blacklist, is_whitelist, stop_transport)#, attached_obj.as_dict())\n            try:\n                _attached_json['body'].append(body(base64.b64encode(_attachment.data.compressedRtf).decode(), \"text/base64\"))\n                _attached_json['body'].append(body(attachment.data.rtfBody, \"text/rtf\"))\n            except: pass\n            for _attach_attached in _attachment.data.attachments:\n                _attached_json['attachment'].append(attachment(filename = _attach_attached.shortFilename, content=_attach_attached.data))\n            _cur_json['attached_emails'][_attachment.shortFilename] = _attached_json\n        elif _attachment.type in 'data':\n            # if attachment in parent msg has binary content\n            _att_counter += 1\n            _cur_json['attachment'].append(attachment(filename = msox_obj['AttachLongFilename'], content = _attachment.data))\n            #_cur_json['attachment'].append(attachment(filename = msox_obj['AttachLongFilename'], content = msox_obj['AttachDataObject']))\n    #        _cur_json['attached_files'].append({\"filename\": _attachment.shortFilename, \"base64_data\":  base64.b64encode\n    #                                (_attachment.data).decode()})\n    return _cur_json    \n\ndef process_attachment(attachment,blacklist, is_whitelist, stop_transport):\n    \n    attached_msg = base64.b64decode(attachment['raw'])\n    \n    try:\n        attached_parsed = EmailParser.decode_email_b(attached_msg, include_raw_body=True, include_attachment_data=True, email_force_tld=True)\n        if len(attached_parsed['header']['to']) == 0 :\n            attached_parsed = parse_msg(attached_msg,blacklist, is_whitelist, stop_transport)\n    except:\n        attached_parsed = parse_msg(attached_msg,blacklist, is_whitelist, stop_transport)\n    return attached_parsed\n\n\ndef main():\n    siemplify = SiemplifyAction()\n    status              = EXECUTION_STATE_COMPLETED  # used to flag back to siemplify system, the action final status\n    output_message      = \"output message :\"  # human readable message, showed in UI as the action result\n    result_value        = None  # Set a simple result value, used for playbook if\\else and placeholders.\n    \n    siemplify.script_name = \"Parse Email\"\n    base64_blob = siemplify.parameters[\"EML/MSG Base64 String\"]\n    blacklist = list(set([x.strip().lower() for x in (siemplify.parameters.get(\"Blacklisted Headers\") or \"\").split(\",\")]))\n    is_whitelist = siemplify.parameters[\"Use Blacklist As Whitelist\"].lower() == \"true\"\n    stop_transport = (siemplify.parameters.get(\"Stop Transport At Header\", \"\") or \"\").strip() or \"\"\n    content = base64.b64decode(base64_blob)\n    \n    try:\n        if olefile.isOleFile(content):\n            m = parse_msg(content, blacklist, is_whitelist, stop_transport)\n            \n        else:\n            \n            m = EmailParser.decode_email_b(content, include_raw_body=True, include_attachment_data=True, email_force_tld=True)\n            \n    except Exception as b:\n        m = EmailParser.decode_email_b(content, include_raw_body=True, include_attachment_data=True, email_force_tld=True)\n    \n    m['attached_emails'] = []\n    m['attachments'] = []\n    attachments = []\n    nested_emails = {}\n    eml_headers = m.get('header')\n    \n    m['urls'] = []\n    m['domains'] = []\n    m['emails'] = []\n    \n    m['observed'] = {}\n    received = {}\n    received['ips'] = []\n    received['emails'] = []\n    received['domains'] = []\n    received['domains_internal'] = []\n    received['foremail'] = []\n    sending = {}\n    sending['hosts'] = []\n    sending['emails'] = []\n    sending['domains'] = []\n  \n    m['received'] = received\n  \n    \n    if 'received_ip' in eml_headers:\n        m['received']['ips'].extend(eml_headers.get('received_ip'))\n        \n    if 'received_email' in eml_headers:\n        m['received']['emails'].extend(eml_headers.get('received_email'))\n    \n    if 'received_domain' in eml_headers:\n        m['received']['domains'].extend(eml_headers.get('received_domain'))\n        \n    if 'received_domains_internal' in eml_headers:\n        m['received']['domains_internal'].extend(eml_headers.get('received_domains_internal'))\n    \n    if 'received_foremail' in eml_headers:\n        m['received']['foremail'].extend(eml_headers.get('received_foremail'))\n    \n    observed = {}\n    observed['urls'] = []\n    observed['domains'] = []\n    observed['emails'] = []\n    observed['ips'] = []\n    m['observed'] = {}\n    m['observed'] = observed\n    \n\n\n    try:\n        for attachment in m['attachment']:\n            attachment['subject'] = m['header']['subject']\n            attachments.append(attachment)\n            try:\n                nested_email = process_attachment(attachment,blacklist, is_whitelist, stop_transport)\n                n_att = []\n                if 'attachment' in nested_email:\n                    for nested_a in nested_email['attachment']:\n                        a = nested_a\n                        del a['raw']\n                        a['subject'] = nested_email['header']['subject']\n                        n_att.append(a)\n                    nested_email['attachments'] = n_att\n                \n                    for nested_attachment in nested_email['attachment']:\n                        #attachments.append(nested_attachment)\n                        try:\n                            nested_nested_email = process_attachment(nested_attachment,blacklist, is_whitelist, stop_transport)\n                            nested_attachments_holder = []\n                            for nested_nested_attachment in nested_nested_email['attachment']:\n                                #attachments.append(nested_nested_attachment)\n                                del nested_nested_attachment['raw']\n                                nested_attachments_holder.append(nested_nested_attachment)\n                            nested_nested_email['attachments'] = nested_attachments_holder\n                            del nested_nested_email['attachment']\n                            nested_nested_email['filename'] = nested_attachment['filename']\n                            nested_emails[nested_attachment['hash']['md5']] = {'filename': nested_attachment['filename'], 'email': nested_nested_email}\n                        except Exception as e:\n                            pass\n                \n                    del nested_email['attachment']\n                \n                nested_email['filename'] = attachment['filename']\n                nested_emails[attachment['hash']['md5']] = {'filename': attachment['filename'], 'email': nested_email}\n            except Exception as b:\n                print(\"failed in attachment parsing\")\n                print(b)\n                pass\n        m['attachments'] = list({v['hash']['sha256']:v for v in attachments}.values())\n        m['attached_emails'] = list(nested_emails.values())\n\n        del m['attachment']\n        for b in m['body']:\n            \n            m['observed']['domains'].extend(b.get('domain', []))\n            m['observed']['urls'].extend(b.get('uri', []))\n            m['observed']['emails'].extend(b.get('email', []))\n\n        for attached_email in m['attached_emails']:\n            for email_body in attached_email['email']['body']:\n                \n                m['observed']['domains'].extend(email_body.get('domain', []))\n                m['observed']['urls'].extend(email_body.get('uri', []))\n                m['observed']['ips'].extend(email_body.get('ip', []))\n                m['observed']['emails'].extend(email_body.get('email', []))\n                \n            eml_headers = attached_email.get('email').get('header')\n            \n            if 'received_ip' in eml_headers:\n                m['received']['ips'].extend(eml_headers.get('received_ip'))\n        \n            if 'received_email' in eml_headers:\n                m['received']['emails'].extend(eml_headers.get('received_email'))\n    \n            if 'received_domain' in eml_headers:\n                m['received']['domains'].extend(eml_headers.get('received_domain'))\n                \n            if 'received_foremail' in eml_headers:\n                m['received']['foremail'].extend(eml_headers.get('received_foremail'))\n\n            if 'received_domains_internal' in eml_headers:\n                m['received']['domains_internal'].extend(eml_headers.get('received_domains_internal'))\n\n        \n        siemplify.LOGGER.info('header')\n        siemplify.LOGGER.info(m['header'])\n        siemplify.LOGGER.info('header')\n        m['observed']['domains'] = list(set(m['observed']['domains']))\n        m['observed']['urls'] = list(set(m['observed']['urls']))\n        m['observed']['emails'] = list(set(m['observed']['emails']))\n        m['observed']['ips'] = list(set(m['observed']['ips']))\n        \n        m['received']['ips'] = list(set(m['received']['ips']))\n        m['received']['emails'] = list(set(m['received']['emails']))\n        m['received']['domains'] = list(set(m['received']['domains']))\n        m['received']['foremail'] = list(set(m['received']['foremail']))\n        m['received']['domains_internal'] = list(set(m['received']['domains_internal']))\n        \n        m['domains'] = m['observed']['domains'].copy()\n        m['domains'].extend(m['received']['domains'])\n        m['domains'].extend(m['received']['domains_internal'])\n        m['domains'] = list(set(m['domains']))\n        \n        m['ips'] =m['observed']['ips'].copy()\n        m['ips'].extend(m['received']['ips'])\n        m['ips'] = list(set(m['ips']))\n        \n        m['emails'] =m['observed']['emails'].copy()\n        m['emails'].extend(m['received']['emails'])\n        m['emails'].extend(m['received']['foremail'])\n        m['emails'] = list(set(m['emails']))\n        \n        m['urls'] = m['observed']['urls']\n        \n\n    except Exception as e:\n        siemplify.LOGGER.error(e)\n        \n        pass\n    \n    \n    siemplify.result.add_result_json(json.dumps(m, sort_keys=True, default=str))\n    siemplify.result.add_json(\"Parsed Mail\", m)\n    \n    output_message = \"Parsed message file.\"\n    siemplify.LOGGER.info(\"\\n  status: {}\\n  result_value: {}\\n  output_message: {}\".format(status,result_value, output_message))\n    siemplify.end(output_message, result_value, status)\n\n\nif __name__ == \"__main__\":\n    main()",
  "IntegrationIdentifier": "EmailUtilities",
  "ScriptResultName": "ScriptResult",
  "DynamicResultsMetadata": [
    {
      "ResultName": "JsonResult",
      "ResultExample": "{\n    \"attached_emails\": [\n        {\n            \"email\": {\n                \"body\": [\n                    {\n                        \"content\": \"string\",\n                        \"content_header\": {\n                            \"content-transfer-encoding\": [\n                                \"string\"\n                            ],\n                            \"content-type\": [\n                                \"string\"\n                            ]\n                        },\n                        \"content_type\": \"string\",\n                        \"domain\": [\n                            \"string\"\n                        ],\n                        \"email\": [\n                            \"string\"\n                        ],\n                        \"hash\": \"string\"\n                    }\n                ],\n                \"filename\": \"string\",\n                \"header\": {\n                    \"date\": \"string\",\n                    \"from\": \"string\",\n                    \"header\": {\n                        \"accept-language\": [\n                            \"string\"\n                        ],\n                        \"authentication-results\": [\n                            \"string\"\n                        ],\n                        \"content-language\": [\n                            \"string\"\n                        ],\n                        \"content-transfer-encoding\": [\n                            \"string\"\n                        ],\n                        \"content-type\": [\n                            \"string\"\n                        ],\n                        \"date\": [\n                            \"string\"\n                        ],\n                        \"from\": [\n                            \"string\"\n                        ],\n                        \"message-id\": [\n                            \"string\"\n                        ],\n                        \"mime-version\": [\n                            \"string\"\n                        ],\n                        \"received\": [\n                            \"string\"\n                        ],\n                        \"return-path\": [\n                            \"string\"\n                        ],\n                        \"subject\": [\n                            \"string\"\n                        ],\n                        \"thread-index\": [\n                            \"string\"\n                        ],\n                        \"thread-topic\": [\n                            \"string\"\n                        ],\n                        \"to\": [\n                            \"string\"\n                        ],\n                        \"x-forefront-antispam-report\": [\n                            \"string\"\n                        ],\n                        \"x-microsoft-antispam\": [\n                            \"string\"\n                        ],\n                        \"x-microsoft-antispam-mailbox-delivery\": [\n                            \"string\"\n                        ],\n                        \"x-microsoft-antispam-message-info\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-antispam-messagedata\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-authas\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-authsource\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-fromentityheader\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-id\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-mailboxtype\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-network-message-id\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-originalarrivaltime\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-crosstenant-userprincipalname\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-authas\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-authmechanism\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-authsource\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-expirationinterval\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-expirationintervalreason\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-expirationstarttime\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-expirationstarttimereason\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-messagedirectionality\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-network-message-id\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-organization-scl\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-processed-by-bccfoldering\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-transport-crosstenantheadersstamped\": [\n                            \"string\"\n                        ],\n                        \"x-ms-exchange-transport-endtoendlatency\": [\n                            \"string\"\n                        ],\n                        \"x-ms-office365-filtering-correlation-id\": [\n                            \"string\"\n                        ],\n                        \"x-ms-oob-tlc-oobclassifiers\": [\n                            \"string\"\n                        ],\n                        \"x-ms-publictraffictype\": [\n                            \"string\"\n                        ],\n                        \"x-ms-tnef-correlator\": [\n                            \"string\"\n                        ],\n                        \"x-ms-traffictypediagnostic\": [\n                            \"string\"\n                        ],\n                        \"x-originating-ip\": [\n                            \"string\"\n                        ]\n                    },\n                    \"received\": [\n                        {\n                            \"by\": [\n                                \"string\"\n                            ],\n                            \"date\": \"string\",\n                            \"from\": [\n                                \"string\"\n                            ],\n                            \"src\": \"string\",\n                            \"with\": \"string\"\n                        }\n                    ],\n                    \"received_domain\": [\n                        \"string\"\n                    ],\n                    \"received_domains_internal\": [],\n                    \"received_ip\": [\n                        \"string\"\n                    ],\n                    \"receiving\": [\n                        {\n                            \"domains\": [\n                                \"string\"\n                            ],\n                            \"emails\": [],\n                            \"hosts\": [\n                                \"string\"\n                            ],\n                            \"ips\": []\n                        },\n                        {\n                            \"domains\": [\n                                \"string\"\n                            ],\n                            \"emails\": [],\n                            \"hosts\": [\n                                \"string\"\n                            ],\n                            \"ips\": [\n                                \"string\"\n                            ]\n                        }\n                    ],\n                    \"sending\": [\n                        {\n                            \"domains\": [\n                                \"string\"\n                            ],\n                            \"emails\": [],\n                            \"hosts\": [\n                                \"string\"\n                            ],\n                            \"ips\": [\n                                \"string\"\n                            ]\n                        },\n                        {\n                            \"domains\": [\n                                \"string\"\n                            ],\n                            \"emails\": [],\n                            \"hosts\": [\n                                \"string\"\n                            ],\n                            \"ips\": []\n                        }\n                    ],\n                    \"subject\": \"string\",\n                    \"to\": [\n                        \"string\"\n                    ]\n                }\n            },\n            \"filename\": \"string\"\n        }\n    ],\n    \"attachments\": [\n        {\n            \"content_header\": {\n                \"content-description\": [\n                    \"string\"\n                ],\n                \"content-disposition\": [\n                    \"string\"\n                ],\n                \"content-transfer-encoding\": [\n                    \"string\"\n                ],\n                \"content-type\": [\n                    \"string\"\n                ]\n            },\n            \"extension\": \"string\",\n            \"filename\": \"string\",\n            \"hash\": {\n                \"md5\": \"string\",\n                \"sha1\": \"string\",\n                \"sha256\": \"string\",\n                \"sha512\": \"string\"\n            },\n            \"raw\": \"string\",\n            \"size\": 1111,\n            \"subject\": \"string\"\n        }\n    ],\n    \"body\": [\n        {\n            \"content\": \"string\",\n            \"content_header\": {\n                \"content-transfer-encoding\": [\n                    \"string\"\n                ],\n                \"content-type\": [\n                    \"string\"\n                ]\n            },\n            \"content_type\": \"string\",\n            \"domain\": [\n                \"string\"\n            ],\n            \"email\": [\n                \"string\"\n            ],\n            \"hash\": \"string\",\n            \"uri\": [\n                \"string\"\n            ]\n        },\n        {\n            \"content\": \"string\",\n            \"content_header\": {\n                \"content-transfer-encoding\": [\n                    \"string\"\n                ],\n                \"content-type\": [\n                    \"string\"\n                ]\n            },\n            \"content_type\": \"string\",\n            \"domain\": [\n                \"string\"\n            ],\n            \"email\": [\n                \"string\"\n            ],\n            \"hash\": \"string\"\n        }\n    ],\n    \"domains\": [\n        \"string\"\n    ],\n    \"emails\": [\n        \"string\"\n    ],\n    \"header\": {\n        \"date\": \"string\",\n        \"from\": \"string\",\n        \"header\": {\n            \"accept-language\": [\n                \"string\"\n            ],\n            \"authentication-results\": [\n                \"string\"\n            ],\n            \"content-language\": [\n                \"string\"\n            ],\n            \"content-type\": [\n                \"string\"\n            ],\n            \"date\": [\n                \"string\"\n            ],\n            \"from\": [\n                \"string\"\n            ],\n            \"message-id\": [\n                \"string\"\n            ],\n            \"mime-version\": [\n                \"string\"\n            ],\n            \"received\": [\n                \"string\"\n            ],\n            \"subject\": [\n                \"string\"\n            ],\n            \"thread-index\": [\n                \"string\"\n            ],\n            \"thread-topic\": [\n                \"string\"\n            ],\n            \"to\": [\n                \"string\"\n            ],\n            \"x-forefront-antispam-report\": [\n                \"string\"\n            ],\n            \"x-microsoft-antispam\": [\n                \"string\"\n            ],\n            \"x-microsoft-antispam-mailbox-delivery\": [\n                \"string\"\n            ],\n            \"x-microsoft-antispam-message-info\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-antispam-messagedata\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-authas\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-authsource\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-fromentityheader\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-id\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-mailboxtype\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-network-message-id\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-originalarrivaltime\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-crosstenant-userprincipalname\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-authmechanism\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-authsource\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-compliancelabelid\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-network-message-id\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-originalclientipaddress\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-originalserveripaddress\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-recordreviewcfmtype\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-organization-submissionquotaskipped\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-processed-by-bccfoldering\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-transport-crosstenantheadersstamped\": [\n                \"string\"\n            ],\n            \"x-ms-exchange-transport-endtoendlatency\": [\n                \"string\"\n            ],\n            \"x-ms-has-attach\": [\n                \"string\"\n            ],\n            \"x-ms-office365-filtering-correlation-id\": [\n                \"string\"\n            ],\n            \"x-ms-oob-tlc-oobclassifiers\": [\n                \"string\"\n            ],\n            \"x-ms-publictraffictype\": [\n                \"string\"\n            ],\n            \"x-ms-traffictypediagnostic\": [\n                \"string\"\n            ],\n            \"x-originating-ip\": [\n                \"string\"\n            ]\n        },\n        \"received\": [\n            {\n                \"by\": [\n                    \"string\"\n                ],\n                \"date\": \"string\",\n                \"from\": [\n                    \"string\"\n                ],\n                \"src\": \"string\",\n                \"with\": \"string\"\n            }\n        ],\n        \"received_domain\": [\n            \"string\"\n        ],\n        \"received_domains_internal\": [],\n        \"received_ip\": [\n            \"string\"\n        ],\n        \"receiving\": [\n            {\n                \"domains\": [\n                    \"string\"\n                ],\n                \"emails\": [],\n                \"hosts\": [\n                    \"string\"\n                ],\n                \"ips\": []\n            },\n            {\n                \"domains\": [\n                    \"string\"\n                ],\n                \"emails\": [],\n                \"hosts\": [\n                    \"string\"\n                ],\n                \"ips\": [\n                    \"string\"\n                ]\n            }\n        ],\n        \"sending\": [\n            {\n                \"domains\": [\n                    \"string\"\n                ],\n                \"emails\": [],\n                \"hosts\": [\n                    \"string\"\n                ],\n                \"ips\": [\n                    \"string\"\n                ]\n            },\n            {\n                \"domains\": [\n                    \"string\"\n                ],\n                \"emails\": [],\n                \"hosts\": [\n                    \"string\"\n                ],\n                \"ips\": []\n            }\n        ],\n        \"subject\": \"string\",\n        \"to\": [\n            \"string\"\n        ]\n    },\n    \"ips\": [\n        \"string\"\n    ],\n    \"observed\": {\n        \"domains\": [\n            \"string\"\n        ],\n        \"emails\": [\n            \"string\"\n        ],\n        \"ips\": [],\n        \"urls\": [\n            \"string\"\n        ]\n    },\n    \"received\": {\n        \"domains\": [\n            \"string\"\n        ],\n        \"domains_internal\": [],\n        \"emails\": [],\n        \"foremail\": [],\n        \"ips\": [\n            \"string\"\n        ]\n    },\n    \"urls\": [\n        \"string\"\n    ]\n}",
      "ShowResult": true
    }
  ],
  "Creator": "Rob",
  "IsEnabled": true,
  "IsCustom": false,
  "IsSystem": false,
  "Version": 56.0,
  "TimeoutSeconds": 600,
  "Parameters": [
    {
      "CustomActionId": 0,
      "IsMandatory": false,
      "DefaultValue": null,
      "Description": "Stop processing the transport at this header field.",
      "Name": "Stop Transport At Header",
      "Value": null,
      "Type": 0,
      "OptionalValues": null,
      "OptionalValuesJson": null,
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1610732892927,
      "ModificationTimeUnixTimeInMs": 1610732892927
    },
    {
      "CustomActionId": 0,
      "IsMandatory": true,
      "DefaultValue": "<insert base64 string>",
      "Description": "The base64 representation of an EML or MSG file.",
      "Name": "EML/MSG Base64 String",
      "Value": "<insert base64 string>",
      "Type": 11,
      "OptionalValues": null,
      "OptionalValuesJson": null,
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1610732892927,
      "ModificationTimeUnixTimeInMs": 1610732892927
    },
    {
      "CustomActionId": 0,
      "IsMandatory": false,
      "DefaultValue": null,
      "Description": "Headers to exclude from the response.",
      "Name": "Blacklisted Headers",
      "Value": null,
      "Type": 0,
      "OptionalValues": null,
      "OptionalValuesJson": null,
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1610732892927,
      "ModificationTimeUnixTimeInMs": 1610732892927
    },
    {
      "CustomActionId": 0,
      "IsMandatory": false,
      "DefaultValue": "false",
      "Description": "To only include the listed headers.",
      "Name": "Use Blacklist As Whitelist",
      "Value": "false",
      "Type": 1,
      "OptionalValues": null,
      "OptionalValuesJson": null,
      "Id": 0,
      "CreationTimeUnixTimeInMs": 1610732892927,
      "ModificationTimeUnixTimeInMs": 1610732892927
    }
  ],
  "DefaultResultValue": "",
  "PythonVersion": "None",
  "Id": 0,
  "CreationTimeUnixTimeInMs": 1610732892921,
  "ModificationTimeUnixTimeInMs": 1621511581000
}